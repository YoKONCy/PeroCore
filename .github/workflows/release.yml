name: "Release"

on:
  workflow_dispatch:
  push:
    branches:
      - tauri

jobs:
  publish-tauri:
    permissions:
      contents: write
    strategy:
      fail-fast: false
      matrix:
        platform: [windows-latest]

    runs-on: ${{ matrix.platform }}
    steps:
      - uses: actions/checkout@v4

      - name: setup node
        uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: 'npm'

      - name: install Rust stable
        uses: dtolnay/rust-toolchain@stable
        with:
          targets: wasm32-unknown-unknown

      - name: Rust Cache
        uses: Swatinem/rust-cache@v2
        with:
          workspaces: "PeroLauncher -> target"

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.10'
          cache: 'pip'

      - name: Install Python dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r backend/requirements.txt

      - name: Prepare Embedded Python Sidecar (Windows)
        shell: pwsh
        run: |
          $PYTHON_VERSION = "3.10.11"
          $PYTHON_URL = "https://www.python.org/ftp/python/$PYTHON_VERSION/python-$PYTHON_VERSION-embed-amd64.zip"
          $TARGET_DIR = "PeroLauncher/src-tauri/python"
          
          if (!(Test-Path $TARGET_DIR)) { New-Item -ItemType Directory -Path $TARGET_DIR -Force }
          
          # 1. 下载并解压嵌入式 Python
          Write-Host "Downloading embedded Python from $PYTHON_URL..."
          Invoke-WebRequest -Uri $PYTHON_URL -OutFile "python_embed.zip"
          Expand-Archive -Path "python_embed.zip" -DestinationPath $TARGET_DIR -Force
          Remove-Item "python_embed.zip"
          
          # 2. 修改 python310._pth，添加 site-packages 路径并启用 site 模块
          $PTH_FILE = "$TARGET_DIR/python310._pth"
          if (Test-Path $PTH_FILE) {
              Write-Host "Patching $PTH_FILE to enable site-packages and Lib..."
              $pth_content = "python310.zip`n.`nLib/site-packages`nimport site"
              Set-Content -Path $PTH_FILE -Value $pth_content
          }
          
          # 3. 安装依赖到该目录下的 site-packages
          $LIB_DIR = "$TARGET_DIR/Lib/site-packages"
          if (!(Test-Path $LIB_DIR)) { New-Item -ItemType Directory -Path $LIB_DIR -Force }
          Write-Host "Installing Python dependencies to $LIB_DIR..."
          pip install -r backend/requirements.txt --target $LIB_DIR --no-warn-script-location

      - name: Build and Install Rust Core Extensions
        shell: pwsh
        run: |
          pip install maturin
          
          $TARGET_LIB = "PeroLauncher/src-tauri/python/Lib/site-packages"
          
          # 1. Build and Install pero_memory_core
          Write-Host "Building pero_memory_core..."
          # Build DLL explicitly for bundling
          cargo build --release --manifest-path backend/rust_core/Cargo.toml
          # Build wheel for Python
          maturin build --release --manifest-path backend/rust_core/Cargo.toml --out dist
          $MEMORY_WHEEL = Get-ChildItem dist/pero_memory_core*.whl | Select-Object -First 1
          if ($MEMORY_WHEEL) {
              Write-Host "Installing $($MEMORY_WHEEL.Name)..."
              pip install $MEMORY_WHEEL.FullName --target $TARGET_LIB --no-deps --force-reinstall
          } else {
              Write-Error "Failed to build pero_memory_core wheel"
              exit 1
          }

          # 2. Build and Install pero_vision_core
          Write-Host "Building pero_vision_core..."
          maturin build --release --manifest-path backend/vision_core/Cargo.toml --out dist
          $VISION_WHEEL = Get-ChildItem dist/pero_vision_core*.whl | Select-Object -First 1
          if ($VISION_WHEEL) {
              Write-Host "Installing $($VISION_WHEEL.Name)..."
              pip install $VISION_WHEEL.FullName --target $TARGET_LIB --no-deps --force-reinstall
          } else {
              Write-Error "Failed to build pero_vision_core wheel"
              exit 1
          }

          # 3. Build and Install nit_rust_runtime
           Write-Host "Building nit_rust_runtime..."
           maturin build --release --manifest-path backend/nit_core/interpreter/rust_binding/Cargo.toml --out dist
           $NIT_WHEEL = Get-ChildItem dist/nit_rust_runtime*.whl | Select-Object -First 1
           if ($NIT_WHEEL) {
               Write-Host "Installing $($NIT_WHEEL.Name)..."
               pip install $NIT_WHEEL.FullName --target $TARGET_LIB --no-deps --force-reinstall
           } else {
               Write-Error "Failed to build nit_rust_runtime wheel"
               exit 1
           }

           # 4. Build CodeSearcher Tool
           Write-Host "Building CodeSearcher Tool..."
           cargo build --release --manifest-path backend/nit_core/tools/work/CodeSearcher/src/Cargo.toml
           
           # Locate and move binary
           # Cargo output structure might vary, so we search for the exe
           $SEARCHER_SRC_DIR = "backend/nit_core/tools/work/CodeSearcher/src"
           $SEARCHER_TARGET_DIR = "backend/nit_core/tools/work/CodeSearcher"
           
           # Try to find the built binary. It's likely in src/target/release or just target/release depending on workspace context
           $SEARCHER_BIN = Get-ChildItem -Path "$SEARCHER_SRC_DIR/target/release/CodeSearcher.exe" -ErrorAction SilentlyContinue
           if (-not $SEARCHER_BIN) {
                # Fallback search
                $SEARCHER_BIN = Get-ChildItem -Path "$SEARCHER_SRC_DIR/../target/release/CodeSearcher.exe" -ErrorAction SilentlyContinue
           }
           
           if ($SEARCHER_BIN) {
               Write-Host "Found CodeSearcher binary at $($SEARCHER_BIN.FullName)"
               Copy-Item -Path $SEARCHER_BIN.FullName -Destination "$SEARCHER_TARGET_DIR/CodeSearcher.exe" -Force
               Write-Host "CodeSearcher.exe deployed to $SEARCHER_TARGET_DIR"
           } else {
               # If strictly required, fail here. Or just warn.
               Write-Warning "CodeSearcher binary not found after build!"
               # Try to list directories to help debug if it fails
               Get-ChildItem -Path "$SEARCHER_SRC_DIR" -Recurse -Filter "CodeSearcher.exe"
           }

           # 5. Build nit_terminal_auditor (Wasm)
           Write-Host "Building nit_terminal_auditor..."
           cargo build --release --target wasm32-unknown-unknown --manifest-path backend/nit_core/nit_terminal_auditor/Cargo.toml
           
           $WASM_SRC = "backend/nit_core/nit_terminal_auditor/target/wasm32-unknown-unknown/release/nit_terminal_auditor.wasm"
           # Fallback path if workspace target dir is used
           if (!(Test-Path $WASM_SRC)) {
               $WASM_SRC = "target/wasm32-unknown-unknown/release/nit_terminal_auditor.wasm"
           }
           
           $WASM_TARGET_DIR = "backend/nit_core/tools/work/TerminalExecutor"
           
           if (Test-Path $WASM_SRC) {
               Write-Host "Found Wasm binary at $WASM_SRC"
               Copy-Item -Path $WASM_SRC -Destination "$WASM_TARGET_DIR/auditor.wasm" -Force
               Write-Host "auditor.wasm deployed to $WASM_TARGET_DIR"
           } else {
               Write-Warning "nit_terminal_auditor.wasm not found after build!"
               # List dirs to debug
               Get-ChildItem -Path "backend/nit_core/nit_terminal_auditor" -Recurse
           }

      - name: install frontend dependencies
        run: npm install

      - name: build frontend
        run: npm run build

      - name: build tauri app
        uses: tauri-apps/tauri-action@v0.5
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          tagName: v${{ github.ref_name }}-${{ github.run_number }}
          releaseName: "Pero Launcher ${{ github.ref_name }} (Build ${{ github.run_number }})"
          releaseBody: "Automated release from GitHub Actions (Tauri v2 + Embedded Python)."
          releaseDraft: false
          prerelease: false
          projectPath: PeroLauncher
          args: --config tauri.conf.pkg.json

      - name: Delete older releases
        if: success()
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const keepCount = 3;
            const { owner, repo } = context.repo;
            
            console.log(`Fetching releases for ${owner}/${repo}...`);
            
            // List all releases
            const releases = await github.paginate(github.rest.repos.listReleases, {
              owner,
              repo,
              per_page: 100
            });
            
            console.log(`Found ${releases.length} releases.`);
            
            // Sort by created_at descending (newest first)
            // Note: GitHub API usually returns them sorted, but we ensure it here.
            releases.sort((a, b) => new Date(b.created_at) - new Date(a.created_at));
            
            if (releases.length <= keepCount) {
              console.log(`Release count (${releases.length}) is within limit (${keepCount}). No action needed.`);
              return;
            }
            
            const releasesToDelete = releases.slice(keepCount);
            
            for (const release of releasesToDelete) {
              console.log(`Deleting release: ${release.name} (${release.tag_name}) - Created at: ${release.created_at}`);
              
              // 1. Delete the release
              try {
                await github.rest.repos.deleteRelease({
                  owner,
                  repo,
                  release_id: release.id
                });
                console.log(`Deleted release ${release.id}`);
              } catch (e) {
                console.error(`Failed to delete release ${release.id}: ${e.message}`);
                continue;
              }
              
              // 2. Delete the tag
              try {
                console.log(`Deleting tag: tags/${release.tag_name}`);
                await github.rest.git.deleteRef({
                  owner,
                  repo,
                  ref: `tags/${release.tag_name}`
                });
                console.log(`Deleted tag ${release.tag_name}`);
              } catch (error) {
                // Tag might have been deleted or not exist
                console.log(`Note: Could not delete tag ${release.tag_name}: ${error.message}`);
              }
            }
