name: "Release"

on:
  workflow_dispatch:
  push:
    branches:
      - tauri

jobs:
  publish-tauri:
    permissions:
      contents: write
    strategy:
      fail-fast: false
      matrix:
        platform: [windows-latest]

    runs-on: ${{ matrix.platform }}
    steps:
      - uses: actions/checkout@v4

      - name: setup node
        uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: 'npm'

      - name: install Rust stable
        uses: dtolnay/rust-toolchain@stable
        with:
          targets: wasm32-unknown-unknown

      - name: Rust Cache
        uses: Swatinem/rust-cache@v2
        with:
          workspaces: "PeroLauncher -> target"

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.10'
          cache: 'pip'

      - name: Install Python dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r backend/requirements.txt

      - name: Prepare Embedded Python Sidecar (Windows)
        shell: pwsh
        run: |
          $PYTHON_VERSION = "3.10.11"
          $PYTHON_URL = "https://www.python.org/ftp/python/$PYTHON_VERSION/python-$PYTHON_VERSION-embed-amd64.zip"
          $TARGET_DIR = "PeroLauncher/src-tauri/python"
          
          if (!(Test-Path $TARGET_DIR)) { New-Item -ItemType Directory -Path $TARGET_DIR -Force }
          
          # 1. 下载并解压嵌入式 Python
          Write-Host "Downloading embedded Python from $PYTHON_URL..."
          Invoke-WebRequest -Uri $PYTHON_URL -OutFile "python_embed.zip"
          Expand-Archive -Path "python_embed.zip" -DestinationPath $TARGET_DIR -Force
          Remove-Item "python_embed.zip"
          
          # 2. 修改 python310._pth，添加 site-packages 路径并启用 site 模块
          $PTH_FILE = "$TARGET_DIR/python310._pth"
          if (Test-Path $PTH_FILE) {
              Write-Host "Patching $PTH_FILE to enable site-packages and Lib..."
              $pth_content = "python310.zip`n.`nLib/site-packages`nimport site"
              Set-Content -Path $PTH_FILE -Value $pth_content
          }
          
          # 3. 安装依赖到该目录下的 site-packages
          $LIB_DIR = "$TARGET_DIR/Lib/site-packages"
          if (!(Test-Path $LIB_DIR)) { New-Item -ItemType Directory -Path $LIB_DIR -Force }
          Write-Host "Installing Python dependencies to $LIB_DIR..."
          pip install -r backend/requirements.txt --target $LIB_DIR --no-warn-script-location

      - name: Prepare Embedded Node.js (Windows)
        shell: pwsh
        run: |
          $NODE_VERSION = "20.18.1"
          $NODE_URL = "https://nodejs.org/dist/v$NODE_VERSION/node-v$NODE_VERSION-win-x64.zip"
          $TARGET_DIR = "PeroLauncher/src-tauri/bin"
          
          if (!(Test-Path $TARGET_DIR)) { New-Item -ItemType Directory -Path $TARGET_DIR -Force }
          
          Write-Host "Downloading Node.js from $NODE_URL..."
          Invoke-WebRequest -Uri $NODE_URL -OutFile "node_embed.zip"
          
          # Extract and move only node.exe
          $TEMP_DIR = "node_temp"
          Expand-Archive -Path "node_embed.zip" -DestinationPath $TEMP_DIR -Force
          
          $EXTRACTED_NODE = Get-ChildItem -Path $TEMP_DIR -Filter "node.exe" -Recurse | Select-Object -First 1
          if ($EXTRACTED_NODE) {
              Copy-Item -Path $EXTRACTED_NODE.FullName -Destination "$TARGET_DIR/node.exe" -Force
              Write-Host "node.exe deployed to $TARGET_DIR"
          } else {
              Write-Error "node.exe not found in zip"
              exit 1
          }
          
          Remove-Item "node_embed.zip"
          Remove-Item $TEMP_DIR -Recurse -Force

      - name: Build and Install Rust Core Extensions
        shell: pwsh
        run: |
          pip install maturin
          
          $TARGET_LIB = "PeroLauncher/src-tauri/python/Lib/site-packages"
          
          # 1. Build and Install pero_memory_core
          Write-Host "Building pero_memory_core..."
          # Build DLL explicitly for bundling
          cargo build --release --manifest-path backend/rust_core/Cargo.toml
          # Build wheel for Python
          maturin build --release --manifest-path backend/rust_core/Cargo.toml --out dist
          $MEMORY_WHEEL = Get-ChildItem dist/pero_memory_core*.whl | Select-Object -First 1
          if ($MEMORY_WHEEL) {
              Write-Host "Installing $($MEMORY_WHEEL.Name)..."
              pip install $MEMORY_WHEEL.FullName --target $TARGET_LIB --no-deps --force-reinstall
          } else {
              Write-Error "Failed to build pero_memory_core wheel"
              exit 1
          }

          # 2. Build and Install pero_vision_core
          Write-Host "Building pero_vision_core..."
          maturin build --release --manifest-path backend/vision_core/Cargo.toml --out dist
          $VISION_WHEEL = Get-ChildItem dist/pero_vision_core*.whl | Select-Object -First 1
          if ($VISION_WHEEL) {
              Write-Host "Installing $($VISION_WHEEL.Name)..."
              pip install $VISION_WHEEL.FullName --target $TARGET_LIB --no-deps --force-reinstall
          } else {
              Write-Error "Failed to build pero_vision_core wheel"
              exit 1
          }

          # 3. Build and Install nit_rust_runtime
           Write-Host "Building nit_rust_runtime..."
           maturin build --release --manifest-path backend/nit_core/interpreter/rust_binding/Cargo.toml --out dist
           $NIT_WHEEL = Get-ChildItem dist/nit_rust_runtime*.whl | Select-Object -First 1
           if ($NIT_WHEEL) {
               Write-Host "Installing $($NIT_WHEEL.Name)..."
               pip install $NIT_WHEEL.FullName --target $TARGET_LIB --no-deps --force-reinstall
           } else {
               Write-Error "Failed to build nit_rust_runtime wheel"
               exit 1
           }

           # 4. Build CodeSearcher Tool
           Write-Host "Building CodeSearcher Tool..."
           cargo build --release --manifest-path backend/nit_core/tools/work/CodeSearcher/src/Cargo.toml
           
           # Locate and move binary
           # Cargo output structure might vary, so we search for the exe
           $SEARCHER_SRC_DIR = "backend/nit_core/tools/work/CodeSearcher/src"
           $SEARCHER_TARGET_DIR = "backend/nit_core/tools/work/CodeSearcher"
           
           # Try to find the built binary. It's likely in src/target/release or just target/release depending on workspace context
           $SEARCHER_BIN = Get-ChildItem -Path "$SEARCHER_SRC_DIR/target/release/CodeSearcher.exe" -ErrorAction SilentlyContinue
           if (-not $SEARCHER_BIN) {
                # Fallback search
                $SEARCHER_BIN = Get-ChildItem -Path "$SEARCHER_SRC_DIR/../target/release/CodeSearcher.exe" -ErrorAction SilentlyContinue
           }
           
           if ($SEARCHER_BIN) {
               Write-Host "Found CodeSearcher binary at $($SEARCHER_BIN.FullName)"
               Copy-Item -Path $SEARCHER_BIN.FullName -Destination "$SEARCHER_TARGET_DIR/CodeSearcher.exe" -Force
               Write-Host "CodeSearcher.exe deployed to $SEARCHER_TARGET_DIR"
           } else {
               # If strictly required, fail here. Or just warn.
               Write-Warning "CodeSearcher binary not found after build!"
               # Try to list directories to help debug if it fails
               Get-ChildItem -Path "$SEARCHER_SRC_DIR" -Recurse -Filter "CodeSearcher.exe"
           }

           # 5. Build nit_terminal_auditor (Wasm)
           Write-Host "Building nit_terminal_auditor..."
           cargo build --release --target wasm32-unknown-unknown --manifest-path backend/nit_core/nit_terminal_auditor/Cargo.toml
           
           $WASM_SRC = "backend/nit_core/nit_terminal_auditor/target/wasm32-unknown-unknown/release/nit_terminal_auditor.wasm"
           # Fallback path if workspace target dir is used
           if (!(Test-Path $WASM_SRC)) {
               $WASM_SRC = "target/wasm32-unknown-unknown/release/nit_terminal_auditor.wasm"
           }
           
           $WASM_TARGET_DIR = "backend/nit_core/tools/work/TerminalExecutor"
           
           if (Test-Path $WASM_SRC) {
               Write-Host "Found Wasm binary at $WASM_SRC"
               Copy-Item -Path $WASM_SRC -Destination "$WASM_TARGET_DIR/auditor.wasm" -Force
               Write-Host "auditor.wasm deployed to $WASM_TARGET_DIR"
           } else {
               Write-Warning "nit_terminal_auditor.wasm not found after build!"
               # List dirs to debug
               Get-ChildItem -Path "backend/nit_core/nit_terminal_auditor" -Recurse
           }

           # Clean target directories to prevent WiX build failure due to long paths or too many files
           # We keep rust_core target because it is explicitly referenced in resources
           Get-ChildItem -Path "backend" -Recurse -Directory -Filter "target" | 
             Where-Object { $_.FullName -notmatch "rust_core" } | 
             Remove-Item -Recurse -Force -ErrorAction SilentlyContinue
           Write-Host "Cleaned up target directories."

      - name: install frontend dependencies
        run: npm install

      - name: Prepare Clean Backend Assets
        shell: pwsh
        run: |
          # Create a distribution directory for backend assets
          $DIST_DIR = "PeroLauncher/backend_dist"
          if (Test-Path $DIST_DIR) { Remove-Item -Path $DIST_DIR -Recurse -Force }
          New-Item -ItemType Directory -Path $DIST_DIR -Force
          
          # Function to Copy with Exclusion
          function Copy-Clean {
              param($Src, $Dest)
              Write-Host "Copying $Src to $Dest ..."
              Copy-Item -Path $Src -Destination $Dest -Recurse -Force
          }
          
          # 1. Copy necessary directories
          $DIRS = @("core", "routers", "assets", "models", "services", "utils", "nit_core")
          foreach ($dir in $DIRS) {
              Copy-Clean -Src "backend/$dir" -Dest "$DIST_DIR/$dir"
          }
          
          # 2. Copy root python files
          Get-ChildItem -Path "backend" -Filter "*.py" | Copy-Item -Destination $DIST_DIR
          
          # 3. Copy built DLL
          # Ensure DLL dir exists
          New-Item -ItemType Directory -Path "$DIST_DIR/rust_core" -Force
          $DLL_SRC = "backend/rust_core/target/release/pero_memory_core.dll"
          if (Test-Path $DLL_SRC) {
              Copy-Item -Path $DLL_SRC -Destination "$DIST_DIR/rust_core/pero_memory_core.dll" -Force
          } else {
              Write-Warning "pero_memory_core.dll not found at $DLL_SRC"
          }
          
          # 4. AGGRESSIVE CLEANUP
          # Remove build artifacts, version control, and temporary files
          Write-Host "Cleaning up unnecessary files..."
          $EXCLUDES = @("target", "node_modules", "__pycache__", ".git", ".vscode", ".idea", "*.pdb", "*.ilk", "*.exp", "*.lib", "*.obj", "*.rlib", "*.rmeta")
          
          foreach ($pattern in $EXCLUDES) {
              Get-ChildItem -Path $DIST_DIR -Recurse -Force | 
                  Where-Object { $_.Name -eq $pattern -or $_.Extension -eq $pattern.TrimStart("*") } | 
                  Remove-Item -Recurse -Force -ErrorAction SilentlyContinue
          }
          
          # Remove Rust source files and configs from bundled assets (not needed for runtime)
          Get-ChildItem -Path $DIST_DIR -Recurse -Include "*.rs", "Cargo.toml", "Cargo.lock" | Remove-Item -Force
          
          # Remove NapCat directory entirely as requested
          $NAPCAT_DIR = "$DIST_DIR/nit_core/plugins/social_adapter/NapCat"
          if (Test-Path $NAPCAT_DIR) {
               Write-Host "Removing NapCat directory..."
               Remove-Item -Path $NAPCAT_DIR -Recurse -Force
          }

          Write-Host "Backend assets prepared in $DIST_DIR"

      - name: build frontend
        run: npm run build

      - name: build tauri app
        uses: tauri-apps/tauri-action@v0.5
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          tagName: v${{ github.ref_name }}-${{ github.run_number }}
          releaseName: "Pero Launcher ${{ github.ref_name }} (Build ${{ github.run_number }})"
          releaseBody: "Automated release from GitHub Actions (Tauri v2 + Embedded Python)."
          releaseDraft: false
          prerelease: false
          projectPath: PeroLauncher
          args: --config tauri.conf.pkg.json

      - name: Delete older releases
        if: success()
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const keepCount = 3;
            const { owner, repo } = context.repo;
            
            console.log(`Fetching releases for ${owner}/${repo}...`);
            
            // List all releases
            const releases = await github.paginate(github.rest.repos.listReleases, {
              owner,
              repo,
              per_page: 100
            });
            
            console.log(`Found ${releases.length} releases.`);
            
            // Sort by created_at descending (newest first)
            // Note: GitHub API usually returns them sorted, but we ensure it here.
            releases.sort((a, b) => new Date(b.created_at) - new Date(a.created_at));
            
            if (releases.length <= keepCount) {
              console.log(`Release count (${releases.length}) is within limit (${keepCount}). No action needed.`);
              return;
            }
            
            const releasesToDelete = releases.slice(keepCount);
            
            for (const release of releasesToDelete) {
              console.log(`Deleting release: ${release.name} (${release.tag_name}) - Created at: ${release.created_at}`);
              
              // 1. Delete the release
              try {
                await github.rest.repos.deleteRelease({
                  owner,
                  repo,
                  release_id: release.id
                });
                console.log(`Deleted release ${release.id}`);
              } catch (e) {
                console.error(`Failed to delete release ${release.id}: ${e.message}`);
                continue;
              }
              
              // 2. Delete the tag
              try {
                console.log(`Deleting tag: tags/${release.tag_name}`);
                await github.rest.git.deleteRef({
                  owner,
                  repo,
                  ref: `tags/${release.tag_name}`
                });
                console.log(`Deleted tag ${release.tag_name}`);
              } catch (error) {
                // Tag might have been deleted or not exist
                console.log(`Note: Could not delete tag ${release.tag_name}: ${error.message}`);
              }
            }
